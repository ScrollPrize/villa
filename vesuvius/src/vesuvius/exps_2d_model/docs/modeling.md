\# Modeling notes

## Coordinate conventions

- All `xy` tensors use **pixel coordinates**:
	- x in `[0, W-1]`, y in `[0, H-1]`.
- The `(x,y)` pair is always stored in the **last** dimension.
	- Examples:
		- sampling grid: `(N,He,We,2)`
		- base mesh: `(N,Hm,Wm,2)`
		- conn endpoints: `(N,Hm,Wm,3,2)`

Notes:

- When sampling with `grid_sample`, pixel coords must be converted to normalized coords `[-1,1]`.
- Validity masks are derived directly from the `xy` tensor being used and are never resized/interpolated.

## Mask correctness (critical)

- Rule: **never interpolate/resize masks**. A mask is only valid for the exact samples it was derived from.
- If you derive a quantity from *multiple* samples, the derived mask must reflect that:
	- For a vector computed from two endpoints (e.g. `x1 - x0`), use `mask = min(mask(x0), mask(x1))`.
	- For a 3-point connection `(left, mid, right)`, treat it as two segments:
		- left-mid mask: `min(mask(left), mask(mid))`
		- mid-right mask: `min(mask(mid), mask(right))`

This is required for the direction loss implementation in [`opt_loss_dir.direction_loss_maps()`](../opt_loss_dir.py:1):

- vertical supervision uses the min-mask across the two mesh vertices forming the v-edge
- connection supervision returns two independent loss maps (left-mid & mid-right) with matching masks

## Direction encoding

Given a direction vector `(gx,gy)` (e.g. a gradient direction), define `theta = atan2(gy,gx)`.

Encodings (normal ambiguity handled by doubling the angle):

- `dir0 = 0.5 + 0.5 * cos(2*theta)`
- `dir1 = 0.5 + 0.5 * cos(2*theta + pi/4)`

Equivalent formulas (avoids computing `theta` explicitly):

- `cos(2*theta) = (gx^2 - gy^2) / (gx^2 + gy^2)`
- `sin(2*theta) = 2*gx*gy / (gx^2 + gy^2)`
- `cos(2*theta + pi/4) = (cos(2*theta) - sin(2*theta)) / sqrt(2)`

This matches `compute_frac_mag_dir()` (training) and the encoding used in [`opt_loss_dir.direction_loss_maps()`](../opt_loss_dir.py:1).

## Scale-space pyramids (residual representation)

- `mesh_ms` and `conn_offset_ms` are stored as **residual pyramids**:
	- integration reconstructs the base (highest-res) tensor by repeatedly **upsampling by 2**, **cropping** to the target shape, and **adding** the residual.
	- see [`Model2D._integrate_param_pyramid()`](../model.py:275) and [`Model2D._upsample2_crop()`](../model.py:410).

- Pyramid shapes are generated by repeatedly halving with **round-up**:
	- `h_{i+1} = max(2, (h_i + 1) // 2)` (same for `w`).
	- this matches the downscale semantics used throughout the model (no silent off-by-one growth).

- Reconstructing a residual pyramid from a target “flat/base” tensor:
	- build per-scale targets by downscaling the flat tensor.
	- compute residuals so that re-integration exactly reproduces the targets at every scale.
	- see [`Model2D._construct_param_pyramid_from_flat()`](../model.py:281).
